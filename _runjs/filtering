class KeywordDictionary
{
    constructor(name)
    {
        this.name = name;
        this.renderWords = {};
    }

    search(renderWord)
    {
        let searchWord = renderWord.type + '_' + renderWord.name;
        return this.renderWords.hasOwnProperty(searchWord);// return in Boolean
    }

    filter(word)
    {
        let filteredKeys = Object.keys(this.renderWords).filter((item) =>
        {
            if (item !== undefined && word !== undefined)
            {
                let serachPos = item.indexOf('_') + 1;
                return (item.toUpperCase().indexOf(word.toUpperCase(), serachPos) === serachPos ? true : false) && (item.toUpperCase() !== word.toUpperCase());
            }
        });

        let filteredRenders = [];

        filteredKeys.forEach(element =>
        {
            filteredRenders.push(this.renderWords[element].getData());
        });

        return filteredRenders;
    }

    add(renderWord)
    {
        let key = renderWord.type + '_' + renderWord.name;
        this.renderWords[key] = renderWord;
    }

    remove(renderWord)
    {
        let key = renderWord.type + '_' + renderWord.name;
        delete this.renderWords[key];
    }
}

class Struct
{
    constructor(data)
    {
      this.name = (data.name) ? data.name : null;
      this.members = (data.members) ? data.members : null;
    }
}

class Keyword
{
    constructor(data)
    {
        this.type = (data.type) ? data.type : null;
        this.name = (data.name) ? data.name : null;
        this.render = (data.render) ? data.render : null;
        this.args = (data.args) ? data.args : null;
        this.members = (data.members) ? data.members : null;
    }

    getData()
    {
        return {
            type: this.type,
            name: this.name,
            render: this.render,
            args: this.args,
        }
    }

    isFunction()
    {
        return this.args !== null;
    }
  
    isStruct()
    {
        return this.members !== null;
    }
  
    isVariable()
    {
        return !this.isFunction() && !this.isStruct();
    }
}
let dict = new KeywordDictionary('Image');
let tmpDict = [];
let res;
console.log('----RAW CODE----------------------------------------------------------------------------------');
res=`struct C_Intersection{vec3 vPos;float fDist;vec3 vNormal;vec3 vUVW;float fObjectId;};
struct C_SpanIntersection{vec3 vNormal;float fDist;float fObjectId;};
struct C_Span{C_SpanIntersection iMin;C_SpanIntersection iMax;};
vec4 RotationToQuaternion(vec3 axis, float angle) {;
vec3 Rotate(vec3 pos, vec3 axis, float angle) {;
mat2 Rot(float a) {;#define LIGHT normalize(vec3(1.0, 1.0, 0.0));
float hoge ,rororo=2.0,ioioi=2.;vec4 pepe, keke=vec4(rororo,2.,3021,0),lololo, jeje=vec4(0.9);
float c1 = sdEllipsoid(Rotate(pos, vec3(0.0, 0.0, 1.0), a.x), size);
float c2 = sdEllipsoid(Rotate(pos + vec3(0.0, 0.0, size.x), vec3(1.0, 0.0, 1.0), a.y), size);
float claw = Claws(pos + vec3(0.0, size.y*0.5, 0.0), vec3(0.075, 0.75, 0.075)*size.y, angles);
vec3 p = opRep(polarPos, vec3(0.25, 7.0, 0.0));
float m = smoothstep(0.1, 1.0, length(pos.xy)) * smoothstep(-1.0, -0.75, cos(uv.x));
float bodyCenter = sdEllipsoid(Rotate(pos, vec3(1.0, 0.0, 0.0), 10.0), vec3(1.2,0.9,1.0));
float body = smax(smin(smin(bodyCenter, smin(bodyFront, bodyFront2, s), s), bodyBack, s), -bodyBackHole, 0.15);
vec3 cp = vec3(sin(cr), cos(cr), 0.0);
float sun = smoothstep(1.0, 0.0, clamp(length(rayDir - LIGHT), 0.0, 1.0));`;
// console.log(res);
console.log('----PARSED CODE------------------------------------------------------------------------------');

let analizeStructs = (str, dict)=>
{
  let isContainStruct = str.match(/struct/g);
  if(!isContainStruct)
  {
    return str;
  }
  else
  {
    let strStructs = [];
    while(str.match(/struct/g))
    {
      let startPos = str.indexOf('struct');
      let endPos = str.indexOf('}');
      strStructs.push(str.substr(startPos, endPos-startPos+1));
      let strFull = strStructs[strStructs.length-1];
      str = str.replace(strFull, '');

      startPos = strFull.indexOf('{');
      endPos = strFull.indexOf('}');
      let strMembers = strFull.substr(startPos, endPos-startPos+1);
      strFull = strFull.replace(strMembers, '');
      strMembers = strMembers.replace(/\{|\}/g, '');
      strMembers = strMembers.replace(/; |;| ;/g, ';');
      strMembers = strMembers.replace(/[ ]+/g, ' ');

      let arrMembers = strMembers.split(';');
      let members = [];
      for(let i=0; i<arrMembers.length; i++)
      {
        if(arrMembers[i]!=='')
        {
          let typeName = arrMembers[i].split(' ');
          members.push(new Keyword({type: typeName[0], name:typeName[1]}));
        }
      }
      let typeName = strFull.split(' ');
      tmpDict.push(new Keyword({type:typeName[0], name:typeName[1], members:members}));
    }
    return str;
  }
};

let analizeFunctionLine = (str, dict)=>
{
    let openBracket = str.indexOf('(');
    let closeBracket = str.indexOf(')', openBracket);
    
    // args
    let args = [];
    let strArgs = str.substr(openBracket, closeBracket-openBracket+1);
    strArgs = strArgs.replace(/ ,|, |,/g, ',');
    strArgs = strArgs.replace(/[()]/g, '');
    strArgs = strArgs.split(',');
    for(let i=0; i<strArgs.length; i++)
    {
        let arg = strArgs[i].split(/ /g);
        args.push(new Keyword({type:arg[0], name:arg[1]}));
    }

    // type/name
    let typeName = str.split(/[ (]/g);
    dict.push(new Keyword({type:typeName[0], name:typeName[1], args:args}));
}

let analizeVariables = (str, dict)=>
{
    //#1: remove brackets
    let lastOpenBracket = str.lastIndexOf('(');
    let firstCloseBracket = str.indexOf(')', lastOpenBracket);
    while(str.match(/\(|\)/g))
    {
      str = str.replace(str.substr(lastOpenBracket, firstCloseBracket-lastOpenBracket+1), '');
      lastOpenBracket = str.lastIndexOf('(');
      firstCloseBracket = str.indexOf(')', lastOpenBracket);
    }
    //#2: remove initializing 
    let eqPos = str.indexOf('=');
    let cmPos = str.indexOf(/,/g);
    cmPos = (cmPos===-1)?str.length:cmPos;
    while(str.match('='))
    {
        str = str.replace(str.substr(eqPos, cmPos-eqPos+1), '');
        eqPos = str.indexOf('=');
        cmPos = str.indexOf(/,/g);
        cmPos = (cmPos===-1)?str.length:cmPos;
    }
    str = str.replace(/ ,|, |,/g, ',');
  
    let typeNames =str.split(/[ ,]/g);
    let type = typeNames[0];
    for(let j=1; j<typeNames.length; j++)
    {
      if(typeNames[j]!=='')
        {
          dict.push(new Keyword({type:type, name:typeNames[j]}));
        }
    }
}

let analyzeLine = function (lineStr)
{
  let isMacro = lineStr.match(/#define/g);
  let isFunction = lineStr.match(/{/g);

  if(isMacro)
  {
    let typeName = lineStr.split(' ');
    tmpDict.push(new Keyword({type:typeName[0], name:typeName[1]}));
  }
  else
  if(isFunction)
  {
    analizeFunctionLine(lineStr, tmpDict);
  }
  else
  {
    analizeVariables(lineStr, tmpDict);
  }
}

res = res.replace(/(?=[ ]+)\,/g, ',')

res = analizeStructs(res);

let array = res.split(';');

for(let i=0; i<array.length; i++)
{
  analyzeLine(array[i])
}

tmpDict.forEach(el=>{
  if(!el.isFunction())console.log(el);
})
for(let key in dict.renderWords){
//   console.log(dict.renderWords[key]);
};
{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/workers/keyword.js","webpack:///./src/js/workers/builtins.js","webpack:///./src/js/workers/keyword_dictionary.js","webpack:///./src/js/workers/tokenizer.js","webpack:///./src/js/workers/keyword.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Keyword","constructor","data","this","type","render","args","members","snippet","getData","isFunction","isStruct","isVariable","gl_Types","split","gl_Keywords","gl_TypesQualifiers","gl_PreProcessor","gl_Builtins","st_Uniforms","st_Variables","st_Exclusions","gl_Types_and_define","concat","push","allTypes","Builtins","init","dictionary","KeywordDictionary","registerBltins","list","categoryId","item","add","isType","str","isExclusionWord","exclusions","renderWords","search","renderWord","searchWord","filter","word","filteredKeys","keys","undefined","serachPos","indexOf","toUpperCase","filteredRenders","forEach","element","substring","remove","Tokenizer","removePrecisions","gl_Precisions","prec","replace","RegExp","removePreProcessor","removeAllBetween","getBetweenStr","start","end","startPos","endPos","substr","length","removeStr","regexp","res","match","strComment","removeAllNested","deepestStart","lastIndexOf","deepestEnd","removeInlineComment","removeBlockComment","sanitizeLinesForStructs","tmp","trim","parseStructs","dict","result","strStructs","strFull","strMembers","arrMembers","typeName","sanitizeLinesForMacroFunctionsVariables","parseMacroLine","parseFunctionLine","strArgs","arg","parseVariables","eqPos","cmPos","typeNames","j","getLinesArray","array","parseMacrosFunctionsVariables","lineStr","isMacro","arrPrevStructs","keywordDict","keyword_dictionary_KeywordDictionary","strPrevCodeFull","linesprevCodeWords","syncMacrosFunctionsVariables","dictName","strNewCodeFull","tokenizer","renewedLineNumbers","linesnewCodeWords","maxLen","Math","max","getRenewedLineNumbers","prevL","some","lineId","k","newL","syncUserDict","syncStructs","onmessage","msg","JSON","parse","builtins","content","strCode","curWord","filteredBuiltinsList","filteredUserList","filteredDict","text","sort","a","b","textA","textB","comparison","postMessage","stringify","filterDictByWord","filterStructByWord"],"mappings":"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","file":"69ee2d0ab72f4dd89909.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/js/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class Keyword\n{\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    constructor(data)\n    {\n        this.type = (data.type) ? data.type : null\n        this.name = (data.name) ? data.name : null\n        this.render = (data.render) ? data.render : null\n        this.args = (data.args) ? data.args : null\n        this.members = (data.members) ? data.members : null\n        this.snippet = (data.snippet) ? data.snippet : null\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    getData()\n    {\n        return {\n            type: this.type,\n            name: this.name,\n            render: this.render,\n            args: this.args,\n            members: this.members,\n            snippet: this.snippet\n        }\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    isFunction()\n    {\n        return this.snippet !== null && this.args !== null\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    isStruct()\n    {\n        return this.snippet !== null && this.members !== null\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    isVariable()\n    {\n        return !this.isFunction() && !this.isStruct()\n    }\n}","import KeywordDictionary from './keyword_dictionary'\nimport Keyword from './keyword'\n\n// Builtin lists\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nconst gl_Types = (\"float vec2 vec3 vec4 int ivec2 ivec3 ivec4 bool bvec2 bvec3 bvec4 mat2 mat3 mat4 void\").split(\" \")\nconst gl_Keywords = (\"break continue do for while if else true false lowp mediump highp precision discard return\").split(\" \")\nconst gl_TypesQualifiers = (\"in out inout const\").split(\" \")\nconst gl_PreProcessor = (\"#define #undef #if #ifdef #ifndef #else #elif #endif\").split(\" \")\nconst gl_Builtins = (\"sin cos tan asin acos atan atan radians degrees pow exp log exp2 log2 sqrt inversesqrt abs ceil clamp floor fract max min mix mod sign smoothstep step ftransform cross distance dot faceforward length normalize reflect refract dFdx dFdy fwidth matrixCompMult all any equal greaterThan greaterThanEqual lessThan lessThanEqual notEqual texelFetch texture textureLod\").split(\" \")\nconst st_Uniforms = (\"iResolution iTime iTimeDelta iFrame iFrameRate iDate iMouse iChannel0 iChannel1 iChannel2 iChannel3 iSampleRate\").split(\" \")\nconst st_Variables = (\"fragColor fragCoord\").split(\" \")\nconst st_Exclusions = (\"mainImage mainSound mainCubemap mainVR\").split(\" \")\nconst gl_Types_and_define = gl_Types.concat(); // For detecting \"#define\" as type.\ngl_Types_and_define.push('#define')\nconst allTypes = gl_Types_and_define.concat()\n\nconst Builtins = {\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    init()\n    {\n        console.log('started: Builtins.init...')\n        this.dictionary = new KeywordDictionary('Builtins')\n        const registerBltins = (list, type, categoryId) =>\n        {\n            for (const item of list)\n            {\n                this.dictionary.add(\n                    new Keyword(\n                        {\n                            type: 'fixed',\n                            name: item,\n                            render: '<span class=\"autocomp-name\">' + item + '</span><div class=\"icon-code-' + categoryId + '\"></div><span class=\"autocomp-type\">' + type + '</span>'\n                        }),\n                )\n            }\n        }\n        registerBltins(gl_Types, 'types', 'gl')\n        registerBltins(gl_Keywords, 'keywords', 'gl')\n        registerBltins(gl_TypesQualifiers, 'type qualifier', 'gl')\n        registerBltins(gl_PreProcessor, 'pre processor', 'gl')\n        registerBltins(gl_Builtins, 'builtin', 'gl')\n        registerBltins(st_Uniforms, 'uniform', 'st')\n        registerBltins(st_Variables, 'variable', 'st')\n    },\n\n    // Check if the word is a type.\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    isType(str)\n    {\n        for (const type of allTypes)\n        {\n            if (str === type) return true\n        }\n        return false\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    isExclusionWord(name)\n    {\n        for (const exclusions of st_Exclusions)\n        {\n            if (name === exclusions) return true\n        }\n        return false\n    }\n}\n\nexport default Builtins","import Builtins from './builtins'\n\nexport default class KeywordDictionary\n{\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    constructor(name)\n    {\n        this.name = name\n        this.renderWords = {}\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    search(renderWord)\n    {\n        const searchWord = renderWord.type + '_' + renderWord.name\n        return this.renderWords.hasOwnProperty(searchWord);// return in Boolean\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    filter(word)\n    {\n        const filteredKeys = Object.keys(this.renderWords).filter((item) =>\n        {\n            if (item !== undefined && word !== undefined)\n            {\n                const serachPos = item.indexOf('_') + 1\n                const isIncluded = (item.toUpperCase().indexOf(word.toUpperCase(), serachPos) === serachPos ? true : false)\n                return isIncluded && (item.toUpperCase() !== word.toUpperCase())\n            }\n        })\n\n        let filteredRenders = []\n\n        filteredKeys.forEach(element =>\n        {\n            const name = element.substring(element.indexOf(\"_\") + 1)\n            if (word !== name && !Builtins.isExclusionWord(name))\n            {\n                filteredRenders.push(this.renderWords[element].getData())\n            }\n        })\n\n        return filteredRenders\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    add(renderWord)\n    {\n        // let val = renderWord\n        // if (Array.isArray(val))\n        // {\n        //     for (let i = 0; i < val.length; i++)\n        //     {\n        //         const renderWord = val[i]\n\n        //     }\n        // }\n        // if (renderWord.type === undefined || renderWord.name === undefined) return\n        const key = renderWord.type + '_' + renderWord.name\n        this.renderWords[key] = renderWord\n        console.log(this.renderWords[key])\n    }\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    remove(renderWord)\n    {\n        if (renderWord.type === undefined || renderWord.name === undefined) return\n        const key = renderWord.type + '_' + renderWord.name\n        delete this.renderWords[key]\n    }\n}\n","import Keyword from './keyword'\nimport Builtins from './builtins'\n\nconst Tokenizer = {\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    removePrecisions(str)\n    {\n        const gl_Precisions = (\"lowp mediump highp\").split(\" \")\n        for (const prec of gl_Precisions)\n        {\n            str = str.replace(new RegExp(prec, 'g'), ' ')\n        }\n        return str\n    },\n\n    removePreProcessor(str)\n    {\n        const gl_PreProcessor = (\"#undef #ifdef #ifndef #else #elif #endif #if\").split(\" \")\n        for (const prec of gl_PreProcessor)\n        {\n            str = this.removeAllBetween(str, new RegExp(prec, 'g'), prec, '\\n')\n        }\n        return str\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    getBetweenStr(str, start, end)\n    {\n        const startPos = str.indexOf(start)\n        const endPos = str.indexOf(end, startPos)\n        return str.substr(startPos, endPos - startPos + end.length)\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    removeStr(str, removeStr)\n    {\n        return str.replace(removeStr, '')\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    removeAllBetween(str, regexp, start, end)\n    {\n        let res = str + ''\n        while (res.match(regexp))\n        {\n            const strComment = this.getBetweenStr(res, start, end)\n            res = res.replace(strComment, '')\n        }\n        return res\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    removeAllNested(str, regexp, start, end)\n    {\n        let res = str + ''\n        let deepestStart = str.lastIndexOf(start)\n        let deepestEnd = str.indexOf(end, deepestStart)\n        while (res.match(regexp))\n        {\n            res = res.replace(res.substr(deepestStart, deepestEnd - deepestStart + 1), '')\n            deepestStart = res.lastIndexOf(start)\n            deepestEnd = res.indexOf(end, deepestStart)\n        }\n        return res\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    removeInlineComment(str)\n    {\n        return this.removeAllBetween(str, /\\/\\//g, '//', '\\n')\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    removeBlockComment(str)\n    {\n        return this.removeAllBetween(str, /\\/\\*/g, '/*', '*/')\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    sanitizeLinesForStructs(str)\n    {\n        let res = ''\n        res = str.replace(/(?=[ ]+)\\,/g, ',')\n\n        let tmp = res + ''\n        res = ''\n\n        tmp.split(/\\r\\n|\\r|\\n/g).forEach(element =>\n        {\n            element = element.split(/\\/\\//g)[0].trim()\n            if (element !== '')\n            {\n                res += element\n            }\n        })\n        return res\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    parseStructs(str, dict)\n    {\n        let result = []\n        str = this.sanitizeLinesForStructs(str)\n        const isContainStruct = str.match(/struct/g)\n        if (!isContainStruct)\n        {\n            return []\n        }\n        else\n        {\n            let strStructs = []\n            while (str.match(/struct/g))\n            {\n                strStructs.push(this.getBetweenStr(str, 'struct', '}'))\n                let strFull = strStructs[strStructs.length - 1]\n                str = this.removeStr(str, strFull)\n\n                let strMembers = this.getBetweenStr(strFull, '{', '}')\n                strFull = this.removeStr(strFull, strMembers)\n                strMembers = this.removeStr(strMembers, /\\{|\\}/g)\n                strMembers = strMembers.replace(/; |;| ;/g, ';')\n                strMembers = strMembers.replace(/[ ]+/g, ' ')\n\n                const arrMembers = strMembers.split(';')\n                let members = []\n                for (let i = 0; i < arrMembers.length; i++)\n                {\n                    let typeName = arrMembers[i].split(' ')\n                    if (typeName[0] && typeName[1])\n                    {\n                        members.push(new Keyword({\n                            type: typeName[0],\n                            name: typeName[1],\n                            render: '<span class=\"autocomp-name\">' + typeName[1] + '</span><div class=\"icon-code-user\"></div><span class=\"autocomp-type\">' + typeName[0] + '</span>'\n                        }))\n                    }\n                }\n\n                const typeName = strFull.split(' ')\n                const name = typeName[1]\n                let snippet = name\n                snippet += ' var_name = '\n                snippet += name\n                snippet += '('\n                for (let i = 0; i < members.length; i++)\n                {\n                    snippet += members[i].type\n                    snippet += '_'\n                    snippet += members[i].name\n                    snippet += (i < members.length - 1) ? ', ' : ''\n                }\n                snippet += ');'\n\n                result.push(new Keyword({\n                    type: typeName[0],\n                    name: name,\n                    members: members,\n                    render: '<span class=\"autocomp-name\">' + name + '</span><div class=\"icon-code-user\"></div><span class=\"autocomp-type\">' + typeName[0] + '</span>',\n                    snippet: snippet\n                }))\n            }\n        }\n        return result\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    sanitizeLinesForMacroFunctionsVariables(str)\n    {\n        let res = ''\n        str = this.removeAllBetween(str, /struct/g, 'struct', '}')\n        str.split(/\\r\\n|\\r|\\n/g).forEach(element =>\n        {\n            element = element.replace(/\\{/g, '{;')\n            element = this.removeStr(element, /\\}/g)\n            element = this.removeStr(element, /(?<=[.])([xyz]+)/g)\n            element = element.replace(/[ ]+/g, ' ')\n            element = element.trim()\n            if (element.match(/\\/\\//g))\n            {\n                element = ''\n            }\n            if (element.match(/precision/g))\n            {\n                element = ''\n            }\n            if (element.match(/#define/g))\n            {\n                element += ';'\n            }\n            if (element !== '')\n            {\n                res += element\n            }\n        })\n        return res\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    parseMacroLine(str, dict)\n    {\n        let result = []\n        str = this.removeAllBetween(str, /\\(/g, '(', ')').trim()\n        const typeName = str.split(' ')\n        result.push(new Keyword({\n            type: typeName[0],\n            name: typeName[1],\n            render: '<span class=\"autocomp-name\">' + typeName[1] + '</span><div class=\"icon-code-user\"></div><span class=\"autocomp-type\">' + typeName[0] + '</span>'\n        }))\n        return result\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    parseFunctionLine(str, dict)\n    {\n        let result = []\n\n        str = str.replace(/\\s/g, ' ')\n        str = str.replace(/[ ]+/g, ' ')\n        str = str.trim()\n\n        // args\n        let args = []\n        let strArgs = this.getBetweenStr(str, '(', ')')\n        strArgs = this.removeStr(strArgs, /[()]/g)\n        strArgs = strArgs.trim()\n        strArgs = strArgs.replace(/\\s/g, ' ')\n        strArgs = strArgs.replace(/\t',/g, ' ')\n        strArgs = strArgs.replace(/inout/g, ' ')\n        strArgs = strArgs.replace(/const/g, ' ')\n        strArgs = strArgs.replace(/in/g, ' ')\n        strArgs = strArgs.replace(/out/g, ' ')\n        strArgs = strArgs.replace(/[ ]+/g, ' ')\n\n        strArgs = strArgs.split(',')\n        for (let i = 0; i < strArgs.length; i++)\n        {\n            let arg = strArgs[i].trim().split(/ /g)\n            if (arg[0] && arg[1])\n            {\n                args.push(new Keyword({\n                    type: arg[0],\n                    name: arg[1],\n                    render: '<span class=\"autocomp-name\">' + arg[1] + '</span><div class=\"icon-code-user\"></div><span class=\"autocomp-type\">' + arg[0] + '</span>'\n                }))\n            }\n        }\n\n        const typeName = str.split(/[ (]/g)\n        const name = typeName[1]\n        let snippet = name + '('\n        for (let i = 0; i < args.length; i++)\n        {\n            snippet += args[i].type\n            snippet += '_'\n            snippet += args[i].name\n            snippet += (i < args.length - 1) ? ', ' : ''\n        }\n        snippet += ')'\n\n        // type/name\n        result.push(new Keyword({\n            type: typeName[0],\n            name: typeName[1],\n            args: args,\n            render: '<span class=\"autocomp-name\">' + typeName[1] + '</span><div class=\"icon-code-user\"></div><span class=\"autocomp-type\">' + typeName[0] + '</span>',\n            snippet: snippet\n        }))\n        return result\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    parseVariables(str, dict)\n    {\n        let result = []\n        //#1: remove brackets\n        str = this.removeAllNested(str, /\\(|\\)/g, '(', ')')\n\n        //#2: remove initializing \n        let eqPos = str.indexOf('=')\n        let cmPos = str.indexOf(/,/g)\n        cmPos = (cmPos === -1) ? str.length : cmPos\n        while (str.match('='))\n        {\n            str = str.replace(str.substr(eqPos, cmPos - eqPos + 1), '')\n            eqPos = str.indexOf('=')\n            cmPos = str.indexOf(/,/g)\n            cmPos = (cmPos === -1) ? str.length : cmPos\n        }\n        str = str.replace(/ ,|, |,/g, ',')\n\n        const typeNames = str.split(/[ ,]/g)\n        const type = typeNames[0]\n        for (let j = 1; j < typeNames.length; j++)\n        {\n            if (typeNames[j] !== '')\n            {\n                result.push(new Keyword({\n                    type: type,\n                    name: typeNames[j],\n                    render: '<span class=\"autocomp-name\">' + typeNames[j] + '</span><div class=\"icon-code-user\"></div><span class=\"autocomp-type\">' + type + '</span>'\n                }))\n            }\n        }\n        return result\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    getLinesArray(str)\n    {\n        let array = []\n        str.split(';').forEach(element =>\n        {\n            if (!element.match(/if|else|switch|for|return/g))\n            {\n                array.push(element)\n            }\n        })\n        return array\n    },\n\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    parseMacrosFunctionsVariables(str, dict)\n    {\n        str = this.sanitizeLinesForStructs(str)\n\n        let result = []\n\n        const array = this.getLinesArray(str)\n\n        for (let i = 0; i < array.length; i++)\n        {\n            const lineStr = array[i].trim()\n            const isMacro = lineStr.match(/#define/g)\n            const isFunction = lineStr.match(/{/g)\n            const isDefinition = Builtins.isType(lineStr.split(' ')[0])\n\n            if (!isDefinition) continue\n\n            if (isMacro)\n            {\n                result.push(this.parseMacroLine(lineStr, dict))\n            }\n            else if (isFunction)\n            {\n                result.push(this.parseFunctionLine(lineStr, dict))\n            }\n            else\n            {\n                result.push(this.parseVariables(lineStr, dict))\n            }\n        }\n        return result\n    }\n}\n\nexport default Tokenizer","//   _   _                                           _ \n//  ( ) ( )                                         ( )\n//  | |/'/'   __   _   _  _   _   _    _    _ __   _| |\n//  | , <   /'__`\\( ) ( )( ) ( ) ( ) /'_`\\ ( '__)/'_` |\n//  | |\\`\\ (  ___/| (_) || \\_/ \\_/ |( (_) )| |  ( (_| |\n//  (_) (_)`\\____)`\\__, |`\\___x___/'`\\___/'(_)  `\\__,_)\n//                ( )_| |                              \n//                `\\___/'                              \n//   _       _               _                         \n//  ( )  _  ( )             ( )                        \n//  | | ( ) | |   _    _ __ | |/')    __   _ __        \n//  | | | | | | /'_`\\ ( '__)| , <   /'__`\\( '__)       \n//  | (_/ \\_) |( (_) )| |   | |\\`\\ (  ___/| |          \n//  `\\___x___/'`\\___/'(_)   (_) (_)`\\____)(_)          \n//                                                     \n\nimport KeywordDictionary from './keyword_dictionary'\nimport Keyword from './keyword'\nimport Tokenizer from './tokenizer'\nimport Builtins from './builtins'\n\n\nlet strPrevStructCode = ''\nlet arrPrevStructs = []\n\n// Dictionaries\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nconst keywordDict = {}\nkeywordDict['Builtins'] = new KeywordDictionary('Builtins')\nkeywordDict['BufferA'] = new KeywordDictionary('BufferA')\nkeywordDict['BufferB'] = new KeywordDictionary('BufferB')\nkeywordDict['BufferC'] = new KeywordDictionary('BufferC')\nkeywordDict['BufferD'] = new KeywordDictionary('BufferD')\nkeywordDict['Image'] = new KeywordDictionary('Image')\nkeywordDict['Sound'] = new KeywordDictionary('Sound')\nkeywordDict['Common'] = new KeywordDictionary('Common')\n\nlet strPrevCodeFull = ''\nlet linesprevCodeWords = ['']\n\nconst initBltinDict = () =>\n{\n    Builtins.init()\n    keywordDict['Builtins'] = Builtins.dictionary\n}\n\nconst filterDictByWord = (dictName, curWord) =>\n{\n    console.log('started: KeywordWorker.filterDictByWord...')\n\n    const filteredBuiltinsList = keywordDict['Builtins'].filter(curWord)\n    const filteredUserList = keywordDict[dictName].filter(curWord)\n    console.log('filteredUserList: ', filteredUserList)\n\n    const filteredDict = filteredBuiltinsList.concat(filteredUserList)\n    console.log('filteredDict: ', filteredDict)\n    if (filteredDict.length >= 1 || (filteredDict[0] !== undefined && filteredDict[0].text !== undefined && filteredDict.length === 1 && filteredDict[0].text.toUpperCase() !== curWord.toUpperCase()))\n    {\n        filteredDict.sort(function (a, b)\n        {\n            // Use toUpperCase() to ignore character casing\n            const textA = a.name.toUpperCase()\n            const textB = b.name.toUpperCase()\n\n            let comparison = 0\n            if (textA > textB)\n            {\n                comparison = 1\n            } else if (textA < textB)\n            {\n                comparison = -1\n            }\n            return comparison\n        })\n    }\n    postMessage(JSON.stringify({ name: 'filter_succeed', content: { list: filteredDict } }, null, \"\\t\"))\n}\n\nconst filterStructByWord = (dictName, curWord) =>\n{\n    console.log('started: KeywordWorker.filterStructByWord...')\n\n    let filteredDict = keywordDict[dictName].filter(curWord)\n    console.log('filteredDict: ', filteredDict)\n\n    if (filteredDict.length === 1)//|| (filteredDict[0] !== undefined && filteredDict[0].text !== undefined && filteredDict.length === 1 && filteredDict[0].text.toUpperCase() !== curWord.toUpperCase()))\n    {\n        filteredDict = keywordDict[dictName].filter(filteredDict[0].type)\n        if (filteredDict[0].members !== null)\n        {\n            console.log('filteredDict[0].members: ', filteredDict[0].members)\n            postMessage(JSON.stringify({ name: 'filter_succeed', content: { list: filteredDict[0].members } }, null, \"\\t\"))\n        }\n    }\n    postMessage(JSON.stringify({ name: 'filter_failed', content: null }, null, \"\\t\"))\n}\n\nconst getRenewedLineNumbers = (str) =>\n{\n    let renewedLineNumbers = []\n    const linesnewCodeWords = str.split(';')\n    const maxLen = Math.max(linesprevCodeWords.length, linesnewCodeWords.length)\n    for (let i = 0; i < maxLen; i++)\n    {\n        if (linesprevCodeWords[i] === undefined) linesprevCodeWords[i] = ''\n        if (linesnewCodeWords[i] === undefined) linesnewCodeWords[i] = ''\n        if (linesprevCodeWords[i] !== linesnewCodeWords[i])// || linesnewCodeWords[i].match(/{/))\n        {\n            renewedLineNumbers.push(i)\n        }\n    }\n    linesprevCodeWords = linesnewCodeWords\n    console.log('Renewed Lines: ', renewedLineNumbers.length)\n    return renewedLineNumbers\n}\n\nconst syncStructs = (dictName, str) =>\n{\n    const result = Tokenizer.parseStructs(str)\n    if (result.length >= 1)\n    {\n        if (arrPrevStructs.length > 0)\n        {\n            for (let i = 0; i < arrPrevStructs.length; i++)\n            {\n                for (let j = 0; j < arrPrevStructs[i].length; j++)\n                {\n                    keywordDict[dictName].remove(result[i][j])\n                }\n            }\n        }\n\n        arrPrevStructs = result.concat()\n\n        // Found structs...\n        for (let i = 0; i < result.length; i++)\n        {\n            keywordDict[dictName].add(result[i])\n        }\n    }\n}\n\nconst syncMacrosFunctionsVariables = (dictName, str) =>\n{\n    const strNewCodeFull = Tokenizer.sanitizeLinesForMacroFunctionsVariables(str)\n    const renewedLineNumbers = getRenewedLineNumbers(strNewCodeFull)\n\n    if (strPrevCodeFull !== '')\n    {\n        const prevL = strPrevCodeFull.split(/\\;/)\n        for (let i = 0; i < prevL.length; i++)\n        {\n            if (renewedLineNumbers.some(lineId => lineId === i))\n            {\n                const renderWords = Tokenizer.parseMacrosFunctionsVariables(prevL[i])\n                for (let j = 0; j < renderWords.length; j++)\n                {\n                    for (let k = 0; k < renderWords[j].length; k++)\n                    {\n                        keywordDict[dictName].remove(renderWords[j][k])\n                    }\n                }\n            }\n        }\n    }\n\n    if (strNewCodeFull !== '')\n    {\n        const newL = strNewCodeFull.split(/\\;/)\n        for (let i = 0; i < newL.length; i++)\n        {\n            if (renewedLineNumbers.some(lineId => lineId === i))\n            {\n                const renderWords = Tokenizer.parseMacrosFunctionsVariables(newL[i])\n                for (let j = 0; j < renderWords.length; j++)\n                {\n                    for (let k = 0; k < renderWords[j].length; k++)\n                    {\n                        keywordDict[dictName].add(renderWords[j][k])\n                    }\n                }\n            }\n        }\n    }\n    strPrevCodeFull = strNewCodeFull\n}\n\nconst syncUserDict = (dictName, str) =>\n{\n    console.log('started: KeywordWorker.syncUserDict...')\n    str = Tokenizer.removeInlineComment(str)\n    str = Tokenizer.removeBlockComment(str)\n    str = Tokenizer.removePrecisions(str)\n    str = Tokenizer.removePreProcessor(str)\n    syncStructs(dictName, str)\n    syncMacrosFunctionsVariables(dictName, str)\n    console.log('keywordDict[dictName].renderWords: ', keywordDict[dictName].renderWords)\n}\n\n\n// Message\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nonmessage = (msg) =>\n{\n    const data = JSON.parse(msg.data)\n    switch (data.name)\n    {\n        case 'initBltinDict':\n            initBltinDict()\n            break\n\n        case 'syncUserDict':\n            syncUserDict(data.content.dictName, data.content.strCode)\n            break\n\n        case 'filterDictByWord':\n            filterDictByWord(data.content.dictName, data.content.curWord)\n            break\n\n        case 'filterStructByWord':\n            filterStructByWord(data.content.dictName, data.content.curWord)\n            break\n\n        default:\n            break\n    }\n}"],"sourceRoot":""}
let shadertoyTypes = "float vec2 vec3 vec4 int ivec2 ivec3 ivec4 bool bvec2 bvec3 bvec4 mat2 mat3 mat4 void".split(" "), shadertoyTypes_and_define = shadertoyTypes.concat(); shadertoyTypes_and_define.push("#define"); let shadertoyUniforms = "iResolution iTime iTimeDelta iFrame iFrameRate iDate iMouse iChannel0 iChannel1 iChannel2 iChannel3 iSampleRate".split(" "), shadertoyVariables = "fragColor fragCoord".split(" "), shadertoyKeywords = "break continue do for while if else true false lowp mediump highp precision discard return".split(" "), shadertoyTypesQualifiers = "in out inout const".split(" "), shadertoyPreProcessor = "#define #undef #if #ifdef #ifndef #else #elif #endif".split(" "), shadertoyBuiltins = "sin cos tan asin acos atan atan radians degrees pow exp log exp2 log2 sqrt inversesqrt abs ceil clamp floor fract max min mix mod sign smoothstep step ftransform cross distance dot faceforward length normalize reflect refract dFdx dFdy fwidth matrixCompMult all any equal greaterThan greaterThanEqual lessThan lessThanEqual notEqual texelFetch texture textureLod".split(" "), replaceAndSeparate = function (e, t, r) { let n = 0, s = ""; for (; ;) { if (void 0 !== (s = e[n]) && s.match(t) && s.length > 1) { s = s.split(t), e.splice(n, 1); let o = 0, i = 0; for (let t = 0; t < s.length; t++)"" === s[t] && t < s.length - 1 ? (e.splice(n + t + i, 0, r), o++) : "" !== s[t] && (e.splice(n + t + i, 0, s[t]), o++ , "" !== s[t] && t < s.length - 1 && (e.splice(n + t + i + 1, 0, r), i++ , o++)); n += o - 1 } if (++n >= e.length) break } return e }, isType = function (e) { for (let t = 0; t < shadertoyTypes_and_define.length; t++)if (e === shadertoyTypes_and_define[t]) return !0; return !1 }, sanitize = function (e) { let t = ""; e.match(/#define/) ? (t = (t = (t = (t = t = t.replace(/(?<=[.])([xyz]+)/g, "")).replace(/[^ a-zA-Z0-9;]/g, " ")).replace(/(?<=[ ])([0-9]?)(?=[ ])/g, "")).replace(/[ ]+/g, " "), element = element.split("//")[0].trim(), element = element.replace("{", "{;"), element = element.replace("}", "")) : e.match(/{/) }, analyzeLine = function (e) { let t = [], r = e.split(" "); if (isType(r[0])) { let n = r.some(e => e.match("{")); if ("#define" === r[0] && (e = r[0] + " " + r[1]), !n) { r = replaceAndSeparate([e], /\(/, "("), e = ""; for (let t = 0; t < r.length; t++) { if (r[t].match(/\)/)) { let e = replaceAndSeparate([r[t]], /\)/, ")"); r[t] = e[e.length - 1] } e += r[t] } if (e.match(/\,/)) { let t = replaceAndSeparate([e], /\,/, ","); e = ""; for (let r = 0; r < t.length; r++)e += replaceAndSeparate([t[r]], /\=/, "=")[0]; e = (t = e.split(" "))[0] + " "; for (let r = 1; r < t.length; r++)e += t[r] } if (e.match(/\=/) && (e = replaceAndSeparate([e], /\=/, "=")[0]), e.match(/\(|\)/)) { let t = e.split(","); e = t[0]; for (let r = 1; r < t.length; r++)!t[r].match(/\(|\)|\.|\W/) && t[r].match(/\D/) && (e += "," + t[r]) } } if (n) { let r = e.split("("); const n = r[0].split(" "), s = n[0], o = n[1]; let i = [], l = r[0]; r[1] && (l = (l = r[1].replace("){", "")).split(",")); for (let e = 0; e < l.length; e++) { const r = l[e].split(" "); for (let e = 0; e < r.length; e++)if (isType(r[e])) { let n = new Keyword({ type: r[e], name: r[e + 1], render: '<span class="autocomp-name">' + r[e + 1] + '</span><div class="icon-code-usr"></div><span class="autocomp-type">' + r[e] + "</span>" }); t.push(n), i.push(n) } } let a = o + "("; for (let e = 0; e < i.length; e++)a += i[e].type, a += "_", a += i[e].name, a += e < i.length - 1 ? ", " : ""; a += ")", t.push(new Keyword({ type: s, name: a, args: i, render: '<span class="autocomp-name">' + o + '</span><div class="icon-code-usr"></div><span class="autocomp-type">fx: ' + s + "</span>" })) } else { let r = e.split(" "), n = r[0]; r = r[1].split(","); for (let e = 0; e < r.length; e++)t.push(new Keyword({ type: n, name: r[e], render: '<span class="autocomp-name">' + r[e] + '</span><div class="icon-code-usr"></div><span class="autocomp-type">' + n + "</span>" })) } } return t }; class KeywordDictionary { constructor(e) { this.name = e, this.renderWords = {} } search(e) { let t = e.type + "_" + e.name; return this.renderWords.hasOwnProperty(t) } filter(e) { let t = Object.keys(this.renderWords).filter(t => { if (void 0 !== t && void 0 !== e) { let r = t.indexOf("_") + 1; return t.toUpperCase().indexOf(e.toUpperCase(), r) === r && t.toUpperCase() !== e.toUpperCase() } }), r = []; return t.forEach(e => { r.push(this.renderWords[e].getData()) }), r } add(e) { let t = e.type + "_" + e.name; this.renderWords[t] = e } remove(e) { let t = e.type + "_" + e.name; delete this.renderWords[t] } } class Keyword { constructor(e) { this.type = e.type ? e.type : null, this.name = e.name ? e.name : null, this.render = e.render ? e.render : null, this.args = e.args ? e.args : null } getData() { return { type: this.type, name: this.name, render: this.render, args: this.args } } isFunction() { return null !== this.args } } var keywordDict = {}; keywordDict.Builtins = new KeywordDictionary("Builtins"), keywordDict.BufferA = new KeywordDictionary("BufferA"), keywordDict.BufferB = new KeywordDictionary("BufferB"), keywordDict.BufferC = new KeywordDictionary("BufferC"), keywordDict.BufferD = new KeywordDictionary("BufferD"), keywordDict.Image = new KeywordDictionary("Image"), keywordDict.Sound = new KeywordDictionary("Sound"), keywordDict.Common = new KeywordDictionary("Common"); var strPrevCodeFull = "", strPrevCodeWords = "", linesprevCodeWords = [""], initBltinDict = function () { function e(e, t, r) { for (let n = 0; n < e.length; n++)keywordDict.Builtins.add(new Keyword({ type: "fixed", name: e[n], render: '<span class="autocomp-name">' + e[n] + '</span><div class="icon-code-' + r + '"></div><span class="autocomp-type">' + t + "</span>" })) } console.log("started: KeywordWorker.initBltinDict..."), e(shadertoyTypes, "types", "gl"), e(shadertoyKeywords, "keywords", "gl"), e(shadertoyTypesQualifiers, "type qualifier", "gl"), e(shadertoyPreProcessor, "pre processor", "gl"), e(shadertoyBuiltins, "builtin", "gl"), e(shadertoyUniforms, "uniform", "st"), e(shadertoyVariables, "variable", "st") }, filterDictByWord = function (e, t) { console.log("started: KeywordWorker.filterDictByWord..."); let r = keywordDict.Builtins.filter(t), n = keywordDict[e].filter(t); console.log("filteredUserList: ", n); let s = r.concat(n); console.log("filteredDict: ", s), (s.length >= 1 || void 0 !== s[0] && void 0 !== s[0].text && 1 === s.length && s[0].text.toUpperCase() !== t.toUpperCase()) && (s.sort(function (e, t) { const r = e.name.toUpperCase(), n = t.name.toUpperCase(); let s = 0; return r > n ? s = 1 : r < n && (s = -1), s }), postMessage(JSON.stringify({ name: "filter_succeed", content: { list: s } }, null, "\t"))), postMessage(JSON.stringify({ name: "filter_failed", content: null }, null, "\t")) }, syncUserDict = function (e, t) { console.log("started: KeywordWorker.syncUserDict..."); let r = ""; t.split(/\r\n|\r|\n/).forEach(e => { (e = (e = (e = e.split("//")[0].trim()).replace("{", "{;")).replace("}", "")).match("#define") && (e += ";"), "" !== e && (r += e) }); let n = r + "", s = (n = (n = n.replace(/(?<=[.])([xyz]+)/g, "")).replace(/[ ]+/g, " ")).split(";"); console.log("linesnewCodeWords:", s); let o = Math.max(linesprevCodeWords.length, s.length), i = (s.length, linesprevCodeWords.length, []); for (let e = 0; e < o; e++)void 0 === linesprevCodeWords[e] && (linesprevCodeWords[e] = " "), void 0 === s[e] && (s[e] = " "), (linesprevCodeWords[e] !== s[e] || s[e].match(/{/)) && i.push(e); let l = strPrevCodeFull.split(/\;/), a = r.split(/\;/); console.log(keywordDict[e]), console.log("linesNeedAnalyze: ", i), console.log("newL: ", a); for (let t = 0; t < l.length; t++)if (i.some(e => e === t)) { let r = analyzeLine(l[t]); for (let t = 0; t < r.length; t++)keywordDict[e].remove(r[t]) } for (let t = 0; t < a.length; t++)if (i.some(e => e === t)) { let r = analyzeLine(a[t]); for (let t = 0; t < r.length; t++)keywordDict[e].add(r[t]) } for (const t in keywordDict[e].renderWords) if (keywordDict[e].renderWords.hasOwnProperty(t)) { let r = keywordDict[e].renderWords[t]; console.log("r: ", r.type, r.name, r.isFunction()) } strPrevCodeFull = r, strPrevCodeWords = n, linesprevCodeWords = s }; onmessage = (e => { let t = JSON.parse(e.data); switch (t.name) { case "initBltinDict": initBltinDict(); break; case "syncUserDict": syncUserDict(t.content.dictName, t.content.strCode); break; case "filterDictByWord": filterDictByWord(t.content.dictName, t.content.curWord) } });